{
  "uuid": "dcf0d8cc-e63f-4c33-8c9e-ba40a57b012c",
  "author": "Toon Ketels",
  "title": "Understanding passport.js authentication flow",
  "alias": "understanding-passportjs-authentication-flow",
  "type": "article",
  "tags": [
    "expressjs",
    "passportjs",
    "nodejs"
  ],
  "content": "<p>Passport.js is a flexible authentication middleware (allowing users to log in) that can be fully customised and works great with connect/express.</p>\n<p>It is flexible in the sense that it allows for different authentication strategies (think via Twitter, via our own user database - installed via separate modules that can be combined) and it allows us to specify any route or output during authentication.</p>\n<p>The <a href=\"https://github.com/jaredhanson/passport-local\">Local Strategy</a> allows us to authenticate users by looking up their data in the app&#39;s database. It has some <a href=\"https://github.com/jaredhanson/passport-local/blob/master/examples/express3/app.js\">great examples how to use it</a>.</p>\n<h2>Different parts in using passport.js</h2>\n<p>There are three main parts in using passport.js:</p>\n<ul>\n<li>Requiring the module and using its <code>passport.initialize()</code> and <code>passport.session()</code> middleware with express.</li>\n<li>Configuring passport with at least one Strategy and setting up passport&#39;s <code>serializeUser</code> and <code>deserializeUser</code> methods.</li>\n<li>Specifying a route which uses the <code>passport.authenticate</code> middleware to actually authenticate a user.</li>\n</ul>\n<p>The example clearly demonstrates the different items. We wont go over it again.</p>\n<h2>Authentication request flow</h2>\n<p>With the tree parts configured as in the example, the following happens when a user tries the authenticate via the <code>/login</code> route:</p>\n<ol>\n<li>When the user submits the login form, a <code>POST</code> request to <code>/login</code> is made resulting in the execution of the <code>passport.authenticate</code> middleware we&#39;ve set up.</li>\n<li>As the authenticate middleware for that route is configured to handle the <code>local</code> strategy, passport will invoke our implementation of the local strategy.</li>\n<li>Passport takes the <code>req.body.username</code> and <code>req.body.password</code> and passes it to our verification function in the local strategy.</li>\n<li>Now we do our thing: loading the user from the database and checking if the password given matches the one in the database.</li>\n<li>In case of an Error interacting with our database, we need to invoke <code>done(err)</code>. When we cannot find the user or the passwords do not watch, we invoke <code>done(null, false)</code>. If everything went fine and we want the user to login we invoke <code>done(null, user)</code>.</li>\n<li>Calling <code>done</code> will make the flow jump back into <code>passport.authenticate</code>. It&#39;s passed the error, user and additional info object (if defined).</li>\n<li>If the user was passed, the middleware will call <code>req.login</code> (a passport function attached to the request).</li>\n<li>This will call our <code>passport.serializeUser</code> method we&#39;ve defined earlier. This method can access the user object we passed back to the middleware. It&#39;s its job to determine what data from the user object should be stored in the session. The result of the <code>serializeUser</code> method is attached to the session as `req.session.passport.user = { // our serialised user object // }.</li>\n<li>The result is also attached to the request as <code>req.user</code>.</li>\n<li>Once done, our requestHandler is invoked. In the example the user is redirected to the homepage.</li>\n</ol>\n<h2>Subsequent authenticated requests flow</h2>\n<p>On subsequent request, the following occurs:</p>\n<ol>\n<li>Express loads the session data and attaches it to the req. As passport stores the serialised user in the session, the serialised user object can be found at <code>req.session.password.user</code>.</li>\n<li>The general passport middleware we setup (<code>passport.initialize</code>) is invoked on the request, it finds the <code>passport.user</code> attached to the session. If is doesn&#39;t (user is not yet authenticated) it creates it like <code>req.passport.user = {}</code>.</li>\n<li>Next, <code>passport.session</code> is invoked. This middleware is a Passport Strategy invoked on every request. If it finds a serialised user object in the session, it will consider this request authenticated. </li>\n<li>The <code>passport.session</code> middleware calls <code>passport.deserializeUser</code> we&#39;ve setup. Attaching the loaded user object to the request as <code>req.user</code>.</li>\n</ol>\n<h2>Summary passport methods and middleware</h2>\n<ul>\n<li><code>passport.initialize</code> middleware is invoked on every request. It ensures the session contains a <code>passport.user</code> object, which may be empty.</li>\n<li><code>passport.session</code> middleware is a Passport Strategy which will load the user object onto req.user if a serialised user object was found in the server.</li>\n<li><code>passport.deserializeUser</code> is invoked on every request by <code>passport.session</code>. It enables us to load additional user information on every request. This user object is attached to the request as <code>req.user</code> making it accessible in our request handling.</li>\n<li>Our Local Strategy is only invoked on the route which uses the <code>passport.authenticate</code> middleware.</li>\n<li>Only during this authentication <code>passport.serializeUser</code> is invoked allowing us the specify what user information should be stored in the session.</li>\n</ul>\n<h2>Overview passport methods attached to the request</h2>\n<p>To finish an overview of passport methods accessible within request handlers:</p>\n<ul>\n<li><code>req.login()</code></li>\n<li><code>req.logout()</code></li>\n<li><code>req.isAuthenticated()</code></li>\n<li><code>req.isUnAuthenticated()</code></li>\n</ul>\n",
  "teaser": "<p>Passport.js is a flexible authentication middleware (allowing users to log in) that can be fully customised and works great with connect/express.</p>\n<p>It is flexible in the sense that it allows for differe...</p>",
  "createDate": "2013-11-01T08:29:55+01:00",
  "updateDate": "2013-11-01T08:29:55+01:00",
  "createDateFormatted": "2013.11.01",
  "updateDateFormatted": "2013.11.01",
  "createDateTimestamp": "1383290995",
  "updateDateTimestamp": "1383290995"
}